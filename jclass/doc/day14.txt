# day14

멤버 변수의 초기화
==> 멤버변수(Field)는 Heap 영역에 생기므로 자동 초기화가 된다.
	하지만 가끔은 변수에 기본적인 값을 지정할 필요가 있다.
	
	1. 명시적 초기화
	==> 변수를 선언하면서 값을 입력하는 방법
		가장 먼저 실행되는 방법
		
		예 ]
			class Test {
				int num = 100;	// 명시적 초기화
			}
	
	2. 초기화 블럭을 이용한 초기화
	==> 이것은 인스턴스 변수에 대해서만 가능한 것으로
		두번째로 실행되는 방법
		
		형식 ]
			{
				이 안에 데이터를 변수에 입력
			}
			
		예 ]
			class Test {
				int num;
				...
				
				{ ==> 초기화 블럭
					num = 10; // 초기화 블럭을 이용한 초기화
				}
			}
	
	3. static 블럭을 이용한 초기화
	==> 2번과 반대로 static 변수에 한해서만 가능한 방법
		두번째로 실행되는 방법
		
		형식 ]
			static {	==> static 블럭
				데이터입력...
			}
			
		예 ]
			class Test {
				static int num;
				...
				
				static {
					num = 50;
				}
			}
			
			
	4. 생성자 함수를 이용한 초기화
	==> 가장 마지막에 실행되는 방법
		
	예 ]
		class Test {
			int num;
			
			public Test(){
				num = 200;
			}
		}
		
----------------------------------------------------------------------------------------------------
객체지향 언어의 특징

	1. 상속			 : 
	2. 다형성
	3. 은닉화/캡슐화 : 변수는 다른 클래스에서 접근하지 못하도록 하고
						데이터를 꺼내거나 입력하는 작업은
						함수를 만들어서 처리하도록 하는 방법

----------------------------------------------------------------------------------------------------
상속 
==> 이미 만들어진 클래스의 기능을 그대로 부여 받아서
	(==> 변수와 함수의 기능을 그대로 복사 받아서)
	새로운 클래스를 만드는 방법
	
	이 개념이 나타나게 된 이유는
	소프트웨어의 개발 속도를 빠르게 하기 위한 한가지 방법이다.
	
	즉, 상속은 객체지향에서 매우 중요한 역할을 하는 것으로...
	
	객체 지향 언어는 부품 단위(클래스)로 프로그램을 만든 후
	그 부품을 조립해서 원하는 결과를 얻어내는 것이다.
	
	어디서 부품(클래스)을 구했는데
	그 기능이 사용자 마음에 꼭 맞지 않을 수도 있다.
	그러면 처음부터 다시 만들어야 하는가?? 하는 문제에서
	이 문제점을 해결하기 위해서 만든 방법이 상속이다.
	
	상속은 자신이 만들고자 하는 부품과 가장 유사한 부품을 가지고 와서
	일단 그 기능을 모두 복사한 후
		1. 없는 기능은 덧붙이고
		2. 있는 기능중 바꿀내용만 바꾸자.
	라는 것이 상속이다.
	
----------------------------------------------------------------------------------------------------
*** : 외워주세요!
상속의 형식 ]
	[접근지정자] [속성] class 클래스이름 	extends	상속해줄클래스이름 {
		이 안에는 우리 눈에 안보이더라도 상속해줄클래스의 멤버들이 모두 포함되어있다.
	}
	
	==> 따라서 상속을 받아서 만드는 클래스는 상속해주는 클래스보다 멤버(변수, 함수)가 늘어난다.
	
	***
	참고 ]
		자바는 오직 단일 상속만 가능하다.
		==> 상속해주는 클래스는 한개여야만 한다.
		
		예 ]
			class NewClass extends Old01, Old02 {
			
			}
			==> 절대로 안된다.
			
			class NewClass extends Old01 {
			}
			==> 정상적으로 상속이 된다.
			
	용어정리 ]
		
		상속을 해준 클래스	-	super Class, 상위클래스, 부모클래스
		상속을 받은 클래스	- 	sub Class, 하위클래스, 자식클래스
		
		is a		==> 상속 관계에 있는 클래스를 부르는 용어
						
						class Father {}
						class Son extends Father {}
						
						이 경우
							Son is a Father 
						가 성립된다.
		
		has a		==> 어떤 클래스 안에 다른 클래스를 멤버로 가지고 있는 상태
						
						class Father {}
						class Son {
							Father f = new Father();
						}
						
						이 경우
							Son has a Father
						가 성립된다.
			
---------------------------------------------------------------------------------------------------
	상속 관계에 있는 경우 생상자의 역할
		
		결론 ]
			하위 클래스가 생성되는 순간
			상위 클래스가 자동 생성된다.
			==> 생성되는 순간 생성자 함수가 호출되므로
				결국 하위 클래스를 생성하면
					상위클래스의 생성자 함수도 실행된다.
					
	결론적으로 상위 클래스의 생성자함수는 자동으로 호출되는 개념이다.
	자동 호출되는 경우는 무조건 기본 생성자만 이용하게 된다.
	참고 ]
		기본생성자 : 매개변수가 없는 생성자
		
	
	**
	참고 ]
		super()
			상위클래스의 특별한 생성자를 강제로 호출하는 기능을 가진 명령
			
			특징 ]
				1. 반드시 생성자 함수 안에서만 사용해야 한다.
				2. 반드시 첫줄 첫문장으로 사용해야 한다.
----------------------------------------------------------------------------------------------------

***
함수의 오버라이딩(Overriding : 함수의 재정의 )
==> 상속관계에 있는 하위 클래스에서
	상위 클래스가 가진 함수의 기능을 수정하는 행위
	
	방법 ]
		0. 상속을 받아야 한다.
		1. 상위 클래스가 가진 함수의 원형과 동일한 원형으로 만들어야 한다.
			참고 ]
				함수의 원형(Prototype)
					반환값타입 + 함수이름 + 매개변수리스트
		2. 접근지정자는 같거나 넓은 방향으로 한다.
		3. 예외처리는 같거나 좁은 방향으로 한다.
		
	이렇게 오버라이딩을 하면
	내부적으로 super의 함수가 숨겨지고 재정의한 함수가 사용된다.
	
	예 ]
		
		class Father {
			void abc(int a){
			}
		}
		
		class Son extends Father {
			void abc(int a) {
				함수내용 수정...
				==> 기능을 변경...
			}
		}

*****
참고 ]
	
	super
	==> this가 실행중인 객체 자기자신을 기억하는 예약된 변수이듯이
		super 역시 예약된 변수 중 하나로
		자신의 상위 클래스의 주소가 기억된 변수
		
		사용목적
			반드시 상위클래스의 멤버임을 밝혀야하는 경우가 생길때 사용한다.
			
-----------------------------------------------------------------------------------------
*****
참고 ]
	상속관계에 있는 클래스에서
	함수는 인스턴스쪽을 따르고
	변수는 레퍼런스 쪽을 따른다. ==> ^^ : [ 가보 ]는 건드리면 안됩니다....
























