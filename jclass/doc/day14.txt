# day14

멤버 변수의 초기화
==> 멤버변수(Field)는 Heap 영역에 생기므로 자동 초기화가 된다.
	하지만 가끔은 변수에 기본적인 값을 지정할 필요가 있다.
	
	1. 명시적 초기화
	==> 변수를 선언하면서 값을 입력하는 방법
		가장 먼저 실행되는 방법
		
		예 ]
			class Test {
				int num = 100;	// 명시적 초기화
			}
	
	2. 초기화 블럭을 이용한 초기화
	==> 이것은 인스턴스 변수에 대해서만 가능한 것으로
		두번째로 실행되는 방법
		
		형식 ]
			{
				이 안에 데이터를 변수에 입력
			}
			
		예 ]
			class Test {
				int num;
				...
				
				{ ==> 초기화 블럭
					num = 10; // 초기화 블럭을 이용한 초기화
				}
			}
	
	3. static 블럭을 이용한 초기화
	==> 2번과 반대로 static 변수에 한해서만 가능한 방법
		두번째로 실행되는 방법
		
		형식 ]
			static {	==> static 블럭
				데이터입력...
			}
			
		예 ]
			class Test {
				static int num;
				...
				
				static {
					num = 50;
				}
			}
			
			
	4. 생성자 함수를 이용한 초기화
	==> 가장 마지막에 실행되는 방법
		
	예 ]
		class Test {
			int num;
			
			public Test(){
				num = 200;
			}
		}
		
----------------------------------------------------------------------------------------------------
객체지향 언어의 특징

	1. 상속			 : 
	2. 다형성
	3. 은닉화/캡슐화 : 변수는 다른 클래스에서 접근하지 못하도록 하고
						데이터를 꺼내거나 입력하는 작업은
						함수를 만들어서 처리하도록 하는 방법

----------------------------------------------------------------------------------------------------
상속 
==> 이미 만들어진 클래스의 기능을 그대로 부여 받아서
	(==> 변수와 함수의 기능을 그대로 복사 받아서)
	새로운 클래스를 만드는 방법
	
	이 개념이 나타나게 된 이유는
	소프트웨어의 개발 속도를 빠르게 하기 위한 한가지 방법이다.
	
	즉, 상속은 객체지향에서 매우 중요한 역할을 하는 것으로...
	
	객체 지향 언어는 부품 단위(클래스)로 프로그램을 만든 후
	그 부품을 조립해서 원하는 결과를 얻어내는 것이다.
	
	어디서 부품(클래스)을 구했는데
	그 기능이 사용자 마음에 꼭 맞지 않을 수도 있다.
	그러면 처음부터 다시 만들어야 하는가?? 하는 문제에서
	이 문제점을 해결하기 위해서 만든 방법이 상속이다.
	
	상속은 자신이 만들고자 하는 부품과 가장 유사한 부품을 가지고 와서
	일단 그 기능을 모두 복사한 후
		1. 없는 기능은 덧붙이고
		2. 있는 기능중 바꿀내용만 바꾸자.
	라는 것이 상속이다.
	
----------------------------------------------------------------------------------------------------
*** : 외워주세요!
상속의 형식 ]
	[접근지정자] [속성] class 클래스이름 	extends	상속해줄클래스이름 {
		이 안에는 우리 눈에 안보이더라도 상속해줄클래스의 멤버들이 모두 포함되어있다.
	}
	
	==> 따라서 상속을 받아서 만드는 클래스는 상속해주는 클래스보다 멤버(변수, 함수)가 늘어난다.
	
	***
	참고 ]
		자바는 오직 단일 상속만 가능하다.
		==> 상속해주는 클래스는 한개여야만 한다.
		
		예 ]
			class NewClass extends Old01, Old02 {
			
			}
			==> 절대로 안된다.
			
			class NewClass extends Old01 {
			}
			==> 정상적으로 상속이 된다.
			
	용어정리 ]
		
		상속을 해준 클래스	-	super Class, 상위클래스, 부모클래스
		상속을 받은 클래스	- 	sub Class, 하위클래스, 자식클래스
		
		is a		==> 상속 관계에 있는 클래스를 부르는 용어
						
						class Father {}
						class Son extends Father {}
						
						이 경우
							Son is a Father 
						가 성립된다.
		
		has a		==> 어떤 클래스 안에 다른 클래스를 멤버로 가지고 있는 상태
						
						class Father {}
						class Son {
							Father f = new Father();
						}
						
						이 경우
							Son has a Father
						가 성립된다.
			
---------------------------------------------------------------------------------------------------
	상속 관계에 있는 경우 생상자의 역할
		
		결론 ]
			하위 클래스가 생성되는 순간
			상위 클래스가 자동 생성된다.
			==> 생성되는 순간 생성자 함수가 호출되므로
				결국 하위 클래스를 생성하면
					상위클래스의 생성자 함수도 실행된다.
					
	결론적으로 상위 클래스의 생성자함수는 자동으로 호출되는 개념이다.
	자동 호출되는 경우는 무조건 기본 생성자만 이용하게 된다.
	참고 ]
		기본생성자 : 매개변수가 없는 생성자
		
	
	**
	참고 ]
		super()
			상위클래스의 특별한 생성자를 강제로 호출하는 기능을 가진 명령
			
			특징 ]
				1. 반드시 생성자 함수 안에서만 사용해야 한다.
				2. 반드시 첫줄 첫문장으로 사용해야 한다.
----------------------------------------------------------------------------------------------------

***
함수의 오버라이딩(Overriding : 함수의 재정의 )
==> 상속관계에 있는 하위 클래스에서
	상위 클래스가 가진 함수의 기능을 수정하는 행위
	
	방법 ]
		0. 상속을 받아야 한다.
		1. 상위 클래스가 가진 함수의 원형과 동일한 원형으로 만들어야 한다.
			참고 ]
				함수의 원형(Prototype)
					반환값타입 + 함수이름 + 매개변수리스트
		2. 접근지정자는 같거나 넓은 방향으로 한다.
		3. 예외처리는 같거나 좁은 방향으로 한다.
		
	이렇게 오버라이딩을 하면
	내부적으로 super의 함수가 숨겨지고 재정의한 함수가 사용된다.
	
	예 ]
		
		class Father {
			void abc(int a){
			}
		}
		
		class Son extends Father {
			void abc(int a) {
				함수내용 수정...
				==> 기능을 변경...
			}
		}

*****
참고 ]
	
	super
	==> this가 실행중인 객체 자기자신을 기억하는 예약된 변수이듯이
		super 역시 예약된 변수 중 하나로
		자신의 상위 클래스의 주소가 기억된 변수
		
		사용목적
			반드시 상위클래스의 멤버임을 밝혀야하는 경우가 생길때 사용한다.
			
-----------------------------------------------------------------------------------------
*****
참고 ]
	상속관계에 있는 클래스에서
	함수는 인스턴스쪽을 따르고
	변수는 레퍼런스 쪽을 따른다. ==> ^^ : [ 가보 ]는 건드리면 안됩니다....
	
==========================================================================================
접근지정자
==> 그 내용을 어디까지 사용할 수 있게 할 것인지를 지정하는 예약된 용어
	즉, 우리가 클래스를 만들면
	그 클래스를 모든 사람들에게 사용할 수 있게 공개해야 되는 것은 아니다.
	클래스를 제작하는 사람이 제작하는 클래스의 사용 범위를 지정할 수 있다.
	
	예 ]
		class 는 누구까지 이 클래스르를 사용하게 하도록 할까?
		new 를 시킬 수 있도록 할 것인가???
		
		함수는 어디까지 이 함수를 호출할 수 있도록 할 것인가??
		
		
	종류 ]
		
		1. private
		==> 절대로 다른 클래스에서는 사용할 수 없고
			오직 자기자신 클래스 내에서만 사용 할 수 있다.
		
		2. 생략
		==> 같은 패키지 소속의 클래스에서는 사용할 수 있다.
		
		3. protected
		==> 같은 패키지 소속의 클래스에서 그리고 상속받은 하위 클래스에서만 사용가능 하다.
		
		4. public
		==> 모든 곳에서 사용가능 하다.
		
		
	참고 ]
		클래스에서는 public 과 생략만 사용할 수 있다.
		
	참고 ]
		클래스의 접근지정의 의미는 클래스 자체를 사용할지 여부를 지정하는 것이고
		생성자함수의 접근지정의 의미는 new 시킬 수 있는지 여부를 지정하는 것이다.

***
은닉화
==> 프로그램에 있어서 가장 중요한 요소는 데이터이다.
	즉, 변수가 프로그램에서의 핵심적인 요소가 되는 것이다.
	무결성 데이터를 유지할 수 있는것이 가장 중요한 개념이 된다.
	
	은닉화란?
	이처럼 중요한 요소인 변수를 사용자가 함부로 변경하지 못하도록
	(결점이 있는 데이터가 오지 못하도록 하는 것)
	방지하는 기법을 은닉화 라고 한다.
	
	방법 ]
		1. 변수의 접근지정자는 private 로 처리한다.
			==> 다른 클래스에서 해당클래스의 변수에 직접 접근할 수 없게된다.
			
		2. 변수의 값을 변경하거나, 값을 꺼내오는 작업은 함수를 통해서 처리한다.
			==> getXXX(), setXXX() 를 만들어서 처리해야한다.
	
------------------------------------------------------------------------------------------
package와 import
	
	package
	==> 자바 프로그램 소스코드가 들어있는 폴더를 
		자바에서 부르는 용어
		
		자바는 오픈 소스이다.
		모든 사람이 자신이 만든 프로그램을 제공할 수 있고
		그것을 모든 사람이 이용할 수 있는 프로그램이다.
		그러다보니 문제점이 생겼는데
			클래스이름이 충돌이 날 수 있다.
		이런 문제를 해결하기 위해서 만들어 놓은 한가지 방법이
		바로 패키지 이다.
		
		즉, 소스코드를 만드는 사람이 그 프로그램이 포함되는 폴더이름 까지
		정해서 프로그램을 만들도록 하는 것..
		
		결론적으로
		자바로 프로그램을 만들때는 반드시 해당 프로그램이 
		어떤 폴더에 저장되는지를 알려주도록 해 놓았다.
		
		명령  ]
			package 폴더이름;
			
	참고 ]
		패키지 이름을 만드는 권장 사항
		
			자신이 사용하는 도메인을 거꾸로 쓴 후 그다음에 다시 폴더이름을 붙여서 사용하세요.
			
		예 ]
			increpas.com
			
			==>
			com.increpas.day14
			
			
-------------------------------------------------------------------------------------------------
import
==> 자신이 사용할 클래스가 어떤 폴더(패키지) 소속의
	클래스 인지를 밝혀주기 위한 명령
	
	예 ]
		내가
				sample
					|----------Test.class
					
				test
					|----------Test.class
					
	형식 1 ]
		import 		패키지경로.클래스이름;
		==> 지정한 폴더에 있는 클래스를 사용할 예정임을 밝히는 것.
		
	형식 2 ]
		import 		패키지경로.*;
		==> 지정한 폴더에 있는 모든 클래스를 사용할 준비를 해두는 것.
		
		
	참고 ]
		형식 2 보다는 형식 1을 우선시 한다.
		
참고 ]
	import 하지 않아도
	명시적으로 클래스이름앞에 패키지이름을 붙여서 사용할 수도 있다.
	
--------------------------------------------------------------------------------------
참고 ]
	유일하게 java.lang 패키지는 import 시키지 않아도 사용할 수 있다.
	왜?
	JVM이 기본적으로 찾아보는 패키지 이기 때문이다.	
	
	
주의 ]
	import 를 하게 되면 해당 패키지만 선언하게 되는 것이다.
	그 상위나 하위는 포함 되지 않는다.
		
		
		p1------------- T1
				|------ T2
				|------ T3
				|------ p2 --------- Q1
								|--- Q2
								|--- Q3
								
		import p1.*;
		==> 이 경우 p1폴더 바로 하위의 클래스들만 사용할 준비를 하는것이다.
			p2 패키지 소속의 클래스들은 상요할 준비를 하는 것이 아니다.
			
			
static import
==> static 멤버는 원칙적으로 
		클래스이름.멤버
	의 형식으로 사용해야 한다.
		
		예 ]
			Math.random();
			Math.PI;
			
	이때 static 멤버앞에 사용하는 클래스이름 조차도 생략할 수 있다.
	==> 이처럼 static 멤버를 사용할 때
		클래스이름을 생략하도록 하는 방법이 static import 이다.
		
	형식 ]
		import 		static 		패키지이름.클래스이름.*;
				























