# day17

Object 클래스
==> 자바로 만든 클래스들의 최상위 클래스 역할을 하는 클래스이다.
	특별히 하는일은 별로 없고
	자바 상속 관계를 명확하게 하기 위한 역할로 주로 사용이 된다.
	
	1. equals()
		==> 비교 함수이다.
			문제는 Object가 가지고 잇는 이 함수는 내용을 비교하는 함수가 아니고
			주소를 비교하는 함수이다.
			연산자중 동등비교연산자와 같은 기능을 가지고 있는 함수이다.
			
		참고 ]
			우리가 String 타입의 데이터를 비교할 때 equals()를 사용해서
			데이터를 비교했었는데..
			이것은 String 이 Object의 equals()를 오버라이드하여
			기능을 데이터를 비교하는 기능으로
			변경시켜 놓은 것이다.
			
		참고 ]
			만약 우리가 제작하는 클래스도 내용 비교를 하도록 원하면
			이 함수를 오버라이드해서 기능을 수정하면 된다.
			
-----------------------------------------------------------------------------------------
사용자 정의 예외 클래스 만들기
==> 예외 클래스는 예외의 발생 원인을 알려주는 역할을 담당한다.
	그런데 어제 강제 예외던지기는 자바가 준비한 예외클래스들만 처리할 수 있다.
	
	만약 우리가 정의한 예외클래스가 있다라고 한다면
	예외의 원인을 파악해주도록 클래스를 작성해야 할 것이다.
	
	사용자 정의 예외클래스는 사용자가 지정한 예외클래스이고
	이 클래스로 예외처리를 할 경우에는 반드시 예외의 원인을 알려주도록 작성해야 하는데
	
	방법 ]
		1. Exception 클래스를 상속 받은 클래스를 제작한다.
		2. toString() 를 오버라이드해서
			예외의 원인을 출력할 수 있도록 한다.
-----------------------------------------------------------------------------------------
String 클래스
==> 문자열을 관리하는 클래스
	
	***
	주의사항 ]
		 String 클래스의 가장 큰 단점
		 ==> String 클래스는 내용이 변경이되면
		 		변경된 내용을 다시 메모리에 저장하고
		 		주소를 다시 저장된 메모리의 주소로 바꾼다.
		 		
		 따라서 String 의 내용변화가 심하면 메모리를 계속해서 누적해서 사용하게 된다.
		 한마디로 메모리의 낭비가 심해진다.
		 
		 그러므로
		 변경이 잦은 문자열은 StringBuffer 또는 StringBuilder 클래스를 사용해서
		 처리하는 것이 좋다.
		 
		참고 ]
			그래도 간단한 문자열 처리는 자주 사용하는 클래스이므로
			"클래스 중 유일하게" new 시키지 않고 사용할 수 있도록 준비해 놓은 클래스이다.
			
			String str1 = new String("홍길동");
			String str2 = "홍길동";
			==> 두가지모두 가능하도록 해 놓았다.
			
		참고 ]
			String 클래스는 클래스 중 유일하게
			+ 연산자를 사용가능하도록 해놓았다.
			
----------------------------------------------------------------------------------------------------
오버라이드 규칙
	
	0.	상속을 받아야 한다.
	1.	함수의 원형을 유지해야 한다.
	2.	접근 지정자는 같거나 넓은 방향으로 해야 한다.
	3.	예외처리(예외전이)는 같거나 좁은 방향으로 처리해야 한다.
	
예 ]
	void add(int a, int b) throws InvalidNumberException, NotANumberException {
	}
	
	==> 오버라이드 할때는
	void add(int a, int b) throws InvalidNumberExceptionm, NotANumberException {
	}	==> O
	
	void add(int a, int b) throws InvalidNumberException {
	}	==> O
	void add(int a, int b) throws NotANumberException {
	}	==> O
	
	void add(int a, int b) throws Exception {
	}	==> X : 예외의 범위가 더 넓은 방향으로 예외전이를 하도록 하는 오버라이드는 불가능하다.
	
----------------------------------------------------------------------------------------------------
StringBuffer
==> String 과 동일하게 문자열을 관리하는 클래스이다.
	
	***
	차이점
		String 클래스는 내용이 변화되면 새로운 메모리를 다시 확보하고
		변화된 내용은 다시 기억한 후 주소를 바꾼다.
		==> String 클래스는 잦은 변화가 생기면 메모리가 많이 소모된다.
		
		StringBuffer는 String의 문제점을 해결하기 위해서
		만들어 놓은 또 하나의 문자열을 관리하는 클래스로
		내용 변화가 있으면 현재 메모리에 변화된 내용을 그대로 기억한다.
		
		StringBuffer는 String과는 다르게
			대입연사자( = )
		를 사용해서 문자열을 기억하는 것은 불가능하고
		반드시 객체지향 원리에 따라서
		반드시 new 시켜서 사용해야 한다.
		
		StringBuffer str = "Hong";						-----> error
		StringBuffer str = new StringBuffer("Hong");	-----> success
		
	참고 ]
		String str = "Hong";
		str = str + "Gil";
		즉 + 연산자를 이용해서 문자열을 결합하는 것 역시
		오직 String 클래스에 한해서 허락한 문법이다.
		
		나머지 클래스는 반드시 그 클래스가 가진 기능(함수)를
		이용해서 필요한 처리를 해줘야 한다.
		
		StringBuffer str = new StringBuffer("Hong");
		str.append(" Gil"); // 원래 기억하던 문자열에 다른 문자열을 결합하는 기능의 함수(append())
		
	참고 ]
		실무에서의 StringBuffer 활용방법
			1. String 이 편리하므로 String 으로 먼저 처리한다.(먼저 만든다.)
				String str = "Hong";
				
			2. 문자열의 변화가 일어나는 시점이 되면
				그순간 StringBuffer 타입으로 변환시킨다.
				
				StringBuffer buff = new StringBuffer(str);
			
			3. StringBuffer 를 이용해서 문자열 변화를 시도한다.
				==> 이때 메모리가 낭비되는 현상이 일어나지 않는다.
				
			4. 문자열 변화가 종료되면 다시 자주 편하게 사용하는 String 클래스 타입으로
				변환시킨다.
					
					str = new String(buff);
					또는
					str = buff.toString();
		
	참고 ]
		StringBuilder
		==> 이 클래스 역시 StringBuffer와 동일한 역할을 하는 클래스이다.
		
			주로 Thread 처리를 할 때 동기화에 대해서 안정적으로 처리가 가능하다.

----------------------------------------------------------------------------------------------------
숙제 ]
	String, StringBuffer, StringBuilder
	클래스가 가지고 있는 주요함수 5개를 조사해서 본인에게 제출하세요.
		내용은 함수의 의미와 사용예제를 만들어보세요.

----------------------------------------------------------------------------------------------------
toString()
==> Object 클래스가 가지고있는 함수로
	Object 클래스에 정의 되어있는 기능은 주소를 비교하는 기능이다.
	
	자바는 주소를 내부적으로 사용하고 있다.
	하지만 주소를 개발자에게 노출하지 않는다.
	
	대신 주소를 출력하면 
		"경로.클래스이름@해쉬코드값" 
	의 형태로 출력하게 된다.
	
	참고 ]
		해쉬코드
		==> 자바는 주소를 내부적으로 해쉬테이블을 이용해서 관리한다.
			해쉬코드값은 그 주소를 관리하는 해쉬테이블의 코드값이 된다.
			
		그런데 주소를 출력하려고 하는 순간 위의 형태로 만들어내야 한다.
		==> 이 작업을 해주는 함수가 바로 toString() 이다.
		
	결론적으로 
		toString()는 주소(변수)를 출력할 때 자동 호출되어서
		출력할 내용을 만들어주는 함수이다.
		
	따라서
		우리가 만드는 클래스를 출력할 때
		다른 내용(클래스의 정보를 출력하도록)하고자 할 경우
		오버라이드해서 사용하면 되겠다.
		
---------------------------------------------------------------------------------------------------------
Object.clone()
	==> 자기 자신을 깊은 복사를 해주는 함수
		
		이 함수는 protected 함수이므로
		상속을 받은 클래스나
		같은 패키지에 있는 클래스에서만 사용할 수 있는데
		우리는 java.lang 패키지 내에 클래스를 만드는 것이 아니므로
		상속을 받아야 사용할 수 있다.
		
		그런데 우리가 제작하는 모든 클래스는 Object 클래스를 자동 상속받아서 만드는 클래스이므로
		자동적으로 이 함수를 사용할 수 있게 된다.
		
Object.hashCode()
	==> 자바는 주소를 노출하지 않도록 하기 위해서
		해쉬테이블을 이용해서 주소를 관리한다.
		그 해쉬테이블에 주소를 관리하는 코드값을 알려주는 함수...
		
		
*****
자바에서 사용하는 모든 데이터는 Object 타입의 변수에 기억될 수 있다.
하지만 Object 타입으로 기억 데이터를 사용할 경우에는
반드시 원래 형태로 강제 형변환을 해서 사용해야 한다.

============================================================================================= 
Math
==> 주로 수학적인 기능을 처리하는 함수로 구성된 클래스이다.
	모든 함수가 static 함수이므로 
	굳이 new 시키지 않아도 사용할 수 있는 클래스이며...
	아예 new 시키지 못하도록 해놓은 클래스이다.
	
=============================================================================================
레퍼클래스(Wrapper Class)
==> 주소를 사용하는 어떤 곳에 Value Type을 사용할 수 없는 문제가 생길 수 있다.
	이런 문제를 해결하기 위해서 만들어진 클래스를 레퍼클래스라고 한다.
	즉, 예를 들어 int를 참조형타입으로 사용할 수 있도록 하기 위해서 만들어진 클래스
	
	참고 ]
		자바는 Object를 중심으로 계층구조화해서
		클래스를 이용하도록 만드는 객체지향 언어이다.
		
		그런데 유일하게 Value Type(기본형데이터 : boolean, char, byte, short, int, log, float, double 8가지)
		만큼은 객체지향원리를 사용하지 않는다.
		따라서 다형성 구현에 있어서 약간의 문제가 생셨다.
		
		예 ]
			void abc(Object o){}
			==> 이 함수는 모든 내용을 처리하도록 만든 함수이다.
				그런데 유일하게 Value Type(기본데이터타입)은 줄수 없게 될 것이다.
				
	참고 ]
		Boxing 과 Unboxing
			
			Boxing이란		Value Type을 주소 타입으로 변환하는 것
				쉽게 말해서 기본데이터타입을 참조형타입으로 변환하는 것을 이야기한다.
			Unboxing이란	Heap 영역에 있는 데이터를 다시 Statck으로 꺼내는 것
				쉽게 말해서 참조형타입의 데이터를 기본데이터타입으로 변환하는 것을 이야기한다.
				
	참고 ]
		레퍼클래스란
			Boxing과 Unboxing을 해주기 위한 클래스
			
	참고 ]
		그런데 요사이는 레퍼클래스를 몰라도 된다.
		왜냐하면 자바 버젼 1.4 이후부터 Boxing과 Unboxing이 자동으로 처리된다.
		
		예 ]
			Integer no = 10;	// ==> Boxing
			int num  = no;		// ==> Unboxing
			
			두 작업이 자동으로 처리가 된다.
			
			결론적으로
			자바는 내부적으로 모든 정보는 주소(참조형타입으로)로 통일해서 사용할 수 있다.
			
	참고 ]
		하지만 유틸리티적인 몇개의 함수는 아직 이용 가능하므로
		완전히 버려진 크래스는 아니다.
		
		예 ]	Integer.parseInt(), Float.parseFloat()
		
=============================================================================================
java.util 패키지 내의 유용한 클래스
	
	1. Objects
		==> 이 클래스는 100% static 함수로만 구성된 클래스
			클래스(객체)를 다룰때 유용한 몇가지 유틸리티적인 함수로 구성된 클래스이다.
			
		예 ]
			boolean isNull(Object obj)
			==> 객체에 내용이 있는지를 확인하는 함수
				즉, new 시킨 결과가 있는지를 확인하는 함수
				
		참고 ]
			null
			==> 주소 변수(참조형변수)에 주소가 없는 상태를 말하는 것이다.
				이것은 찾아갈 대상이 없는 상태이고
				이 말은 곳 이것은 아직 사용할 준비가 되지 않았다는 말이다.

	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	2. Random 클래스
		==> 난수를 발생하는 클래스이다.
			우리가 알고 있는 Math.random() 함수 보다는
			좀더 다양한 형태의 난수를 발생할 수 있는 장점이 있다.
			
		참고 ]
			seed
				컴퓨터에서 난수 발생은 그 순간 실제로 난수를 만들어주는 것이 아니고
				이미 컴퓨터 내부에는 난수 테이블이 존재하고 있다.
				그리고 이 난수 테이블에서 순서대로 개내서 주는 역할을 하는 것이다.
				
				seed란? 난수 테이블에서 난수를 꺼내는 위치를 말하는 용어이다.
				
	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	
	3. Arrays 클래스
		==> 역시 100% static 함수로만 구성된 클래스
			배열을 기억하는 함수가 아니고
			배열을 처리할 때 필요한 유틸리티적인 함수들로 구성된 클래스
			
			예 ]
				sort(???)
				==> 배열에 있는 데이터를 정렬하는 기능을 가진 함수
				
				toString(???)
				==> 배열의 내용을 문자열로 반환해주는 기능을 가진 함수
				
=============================================================================================


오늘 배웠던 클래스들의 함수를 조사해보세요...











	