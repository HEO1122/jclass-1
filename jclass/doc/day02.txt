#day02

자바 프로그램의 토큰 구분
==> 컴파일러는 토큰 단위로 번역을 시도한다.
	따라서 개발자는 컴파일러가 번역하는 토큰을 구분해줘야 한다.
	이것이 ";" 이라는 기호를 이용해서 구분하게 된다.
	
	우리가 습관적으로
		int a = 10;
	이라고 기술한 이유가 토큰을 구분하기 위한 기호였다.
	
	결론적으로 토큰이란 하나의 명령이 종료되었음을 알려주는 기호이다.
	
	만약 개발자 토큰을 구분하지 않으면 오류가 날 수 있다.
	
	예 ]
		int a = 10
		int b = 20;
		==> 컴파일러는 두줄을 하나의 명령으로 인식해서
			처리하게 될 것이고 
			이런 명령형식은 자바에는 존재하지 않으므로
			에러가 발생한다.
			
	예 ]
		int a = 10; int b = 20;
		==> 한 줄로 입력했지만
			두개의 명령으로 인식하여 먼저
				int a = 10;
			만 컴파일하고
				int b= 20;
			은 따로 컴파일하게 되서
			안전하게 컴파일이 완성이 된다.
			
	참고 ]
		토큰기호는 ; 대신 {} 기호가 그역할을 대신할 수 있다.
		
	예 ]
		if(조건식) {
			처리내용
		}
		==> 이경우 ; 은 없지만 } 가 그역할을 대신하기 때문에
			컴파일러는 {} 를 별도로 컴파일하게 된다.
			토큰이 발생했다. 라고 이야기할 수 있다.
			
참고 ]
	==> 키보드를 이용해서 데이터 입력 받기
		( 이 부분은 OOP(객체지향)이론을 먼저 공부한 후 이해할 수 있다. )
		
		1. class가 만들어지기 이전에
				import java.util.*;
			라는 명령을 이용해서 사용할 라이브러리를 등록한다.
		2. 프로그램에 들어가는(주로 main함수 내에서)
		
			Scanner sc = new Scanner(System.in);
			이라는 명령을 이용해서 키보드를 통해서 입력받을 도구를
			준비한다.
		
		3. 키보드를 통해서 입력받을 필요가 생기면...
			
			변수 = sc.nextXXX();
			명령을 이용해서 데이터를 입력 받으면 된다.
			
			이때 XXX는 입력받을 데이터의 종류에 따라서 달라진다.
			
			예 ]
				문자열을 입력받고 싶으면
				
				String str = sc.nextLine();
				
				정수로 입력받고 싶으면
				int num = sc.nextInt();
				
				실수로 입력받고 싶으면
				float num = sc.nextFloat();

참고 ]
	숫자형식의 문자열을 숫자로 변환시키는 방법
		
		예 ]
			
			"123"	==> 콘솔화면에서는 숫자로 보이지만
						실제로는 문자열의 데이터이다.
						이것은 사칙연산을 할 수 없는 데이터이다.
						
			이것을 실제 계산이 가능한 숫자로 변환하는 방법
				
				int no = Integer.parseInt("문자열데이터");
				
				==> int no = Integer.parseInt("123");
					==> 문자열 "123"을 정수 123로 변환시켜주는 함수이다.
					
--------------------------------------------------------------
문제 ]
	세자리 숫자를 입력받아서
	100을 뺀 값을 출력해주는 프로그램을 작성하세요.

문제 2 ]
	사각형의 가로와 세로의 길이를 정수로 입력받아서
	넓이를 출력해주는 프로그램을 작성하세요.
	
문제 3 ]
	삼각형의 밑변과 높이를 정수로 입력받아서
	넓이를 출력해주는 프로그램을 작성하세요.
	
문제 4 ] 변수 만드는 연습용...
	친구의 이름, 나이, 신장, 전화번호를 입력받아서
	출력해주는 프로그램을 작성하세요.
--------------------------------------------------------------

형변환(Casting)
==> 데이터를 사용하다보면 데이터의 형태를 바꿔야 할 필요가 생긴다.
	이처럼 데이터의 형태를 변경하는 것을 "형변환" 이라고 한다.
	
	1. 자동형변환
		==> 개발자가 지정하지 않아도 자동적으로 형태를 바꿔서 
			사용되는 경우
			
			발생하는 경우
			==> 작은 형태의 데이터가 큰 형태의 데이터로 필요한 경우
				자동 형변환이 일어난다.
				
			예 ]
				float no = 10;
				==> no는 float 타입의 실수형 변수이고
					10 정수형데이터인데 타입은 int 이다.
					
					이때 입력크기로 비교하자면
					두개의 타입모두 4바이트를 기억할 수 있어서 같은 크기이지만
					타입이 서로 다른 경우에는 바이트로 비교하지 않고
					항상 언제나 실수 데이터가 바이트와 무관하게 크다.
				
				------------------------------------------------------	
				참고 ]
					실수는 주어진 비트를 3개의 영역(부호, 소수, 데이터영역)으로 분리해서
					입력된 데이터를 지수형태의 데이터로 만들어서
					각각의 영역에 기억하도록 하는 방식을 사용한다.
				------------------------------------------------------	
					
					따라서 정수와 실수의 연산의 결과는 항상 실수가 된다.
					
				하지만 만약
					
					float no = 10.;
					==> 이경우 10. 은 실수 데이터이고
						자바에서는 실수데이터의 기본타입이 double 이기때문에
						10. 데이터가 변수보다 크기 크다.
						따라서 이경우는 에러가 발생한다.
						
				결론적으로 큰 타입의 변수에 작은 타입의 데이터를 대입하는 경우는
				자동 형변환이 일어난다.
				
	2. 강제형변환
		==> 자동 형변환이 불가능한 경우
			경우에 따라서는 개발자가 강제로 형 변환을 해줘야하는 필요가 생긴다.
			
			형식 ]
				(변환할타입) 데이터;
				
				예 ]
					
					float no = (float) 10.;
					==> 
						10.	- double 타입 데이터(8바이트)
						no  - float 타입의 변수(4바이트)
						
			참고 ]
				강제 형변환을 하면
				데이터가 손실될 위험이 생긴다.
				
			참고 ]
				실제 데이터 자체는 변함이 없다.
				
		1, 2 번의 경우 공통적으로 사용하는 시점에 형태가 변환된다.
		
		
	3. 리터럴형변환
		==> 리터럴 풀에 담기는 데이터의 형태를 변형시키는 방법
		
		형식 ]
			
			정수의 경우 : 데이터L(또는 l)
			실수의 경우 : 데이터F(또는 f)
			
		예 ]
			
			float pi = 3.14f;

----------------------------------------------------
사칙연산자 
	+	: 더하기
	-	: 빼기
	*	: 곱하기
	/	: 나누기
	%	: 나머지

대입 연산자
	=, +=, -=, *=, /=, %=
	
	기본 기호 ] 	=
	
	형식 ] 
		변수 = 데이터;
	
	의미 ]
		데이터를 변수에 기억하라.
		
	참고 ]
		자바의 모든 연산은 반드시 대입연산자가 있어야 기억을 할 수 있다.
		만약 대입하지 않으면 연산의 결과는 기억되지 못한다.
		
	참고 ]
		모든 연산자는 같은 연산자가 중복된 경우 왼쪽에서 오른쪽으로 진행하면서 계산된다.
		
		예 ]
			
			3 + 5 + 7
			
			연산방향
			-------->
			 3+ 5 를 먼전 계산
			 (3+5) 의 결과를 가지고 다시 + 7 연산을 한다.
			 
			하지만 유일하게 대입 연산자 마큼은 오른쪽에서 왼쪽으로 진행해서 처리한다.
			
			int no = 4 + 5;
			
			산술연산	------>
			대입연산   <---
		
		참고 ]
			
			int a;
			int b;
			int c;
			
			a = b = c = 10;

		참고 ]
			변수선언의 경우
			같은 타입의 데이터는 , 구분자로 나열해서 선언할 수 있다.
			
			int a, b, c;
			
			int a, b, c = 10;	---- O

-----------------------------------------------------

연산자의 우선순위
==> 하나의 연산식에서 여러 연산자가 혼합된 경우 무엇을 먼저 처리하는가를
	정해놓은 규칙
	
	규칙 ]
		
		산술 > 비교 > 논리 > 대입
	
	***
	결론 ]
		대입연산자는 모든 연산이 종료된 후 실행된다.
		항상 연산이 끝난 후 그 결과가 기억된다.
		
------------------------------------------------------
증감연산자
==> 
	주기억장치(메모리)에서 직접연산되는 연산자.
	대입하지 않아도 변수 자체가 변경되는 연산자.
	
	기호 ]
		++, --
		
	의미 ]
		연산자가 붙어있는 변수의 데이터를 1씩 증가 또는 감소 시키세요.
		
		참고 ]
			
			연산기호를 기준으로 값을 예측하면 된다.
		
	예 ]
		int a = 10;
		
		System.out.println(++a); // 11이 출력된다.
		
		int b = 20;
		System.out.println(b++);	// 20이 출력된다.
		
		System.out.println(++b);
		
	주의 ]
		이 연산자는 다른 연산자와 혼합되어 있는 경우
		(연산을 해야 하는 데이터가 다른 연산자(명령)에도 사용되는 경우)
		(하나의 식 안에 다른 연산자와 증감 연산자가 같이 있는 경우)
		다른 연산자와 실행 순서가 달라질 수 있다.
		
		예 ]
			b = ++a;
			
		종류 ]
			
			선처리 증감
				형식 ]
					++변수
					==> 증감을 먼하고 다른 연산을 나중에 한다.
					
			후처리 증감
				형식 ]
					변수++
					==> 다른 연산을 먼저하고 나중에 오는 변수에 1증감하라.
					
--------------------------------------------------------------
숙제 ]
	다음 연산 결과를 예측하고 
	프로그램을 작성해서 예측이 맞는지 확인하세요.
	맨 마지막에 기억된 변수들의 값을 예측하고 출력하세요.
	
	1)
		int a = 10;
		int b = ++a + ++a;
		
	2)
		int a = 10;
		int b = ++a + a++;
		
	3) 
		int a = 10;
		int b = a++ + a++;
		
--------------------------------------------------------------
부호 반전 연산자
==> 현재의 부호를 반대로 바꾸는 연산자
	즉, 양수이면 음수로 음수이면 양수로 바꿔주는 연산자.
	
	기호 ]
		-
		
	형식 ]
		-데이터;
		
--------------------------------------------------------------
비교연산자
==> 두 데이터의 크기 관계를 비교하는 연산자.
	결과값은 boolean 타입의 데이터 true, false 로 반환해준다.
	
	기호 ]
		
		==	: 같다
		!=	: 다르다.
		>	: 크다
		<	: 작다
		>=	: 크거나 같다.
		<=	: 작거나 같다.
		
	주의 ]
		사용되는 데이터와 관계없이 결과는 항상 논리값으로 나온다.
		
	참고 ]
		이 연산자는 주로 if,... 등의 제어 명령에서 질문이 필요할 때
		많이 사용되는 연산자 이다.
		
	참고 ]
		문자열은 엄밀히 말해서 일반 데이터가 아니다.
		따라서 문자열은 비교할 때 조심해서 사용해야 한다.
		
		문자열 부분은 내일아침 수업하겠습니다.
		
	참고 ]
		문자 데이터도 크기 비교가 가능하다.
		문자 데이터는 아스키코드값으로 기억되기 때문에
		그 코드값으로 대소비교를 하게 된다.
		
------------------------------------------------------
논리 연산자
==> 두 논리값 사이의 관계를 따지는 연산자.






