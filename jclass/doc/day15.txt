# day15

-------------------------------------------------------------------------------------------------------
참고 ]
	상속을 사용하는 이유....
		누군가 내가 필요한 기능을 이미 구현해 놓은 경우
		그 클래스에 내가 원하는 기능만 모아놓지는 않았을 것이다.
		
		즉, 내가 필요한 기능이 없을 수도 있고
		필요한 기능이 기능이 있지만 내가 사용하기에는 조금 수정해야 하는 것도 있을 것이다.
		
		이때 상속은 이미 구현해놓은 클래스의 기능을 
		모자라면 추가하고
		고쳐야하면 수정해서 사용하라고 있는 것이 되겠다.
		
		이렇게 하면
		원하는 기능을 조금만 수정해도 프로그램을 구현할 수 있기 때문에
		프로그램 제작 속도가 빨라질 것이다.
		
-------------------------------------------------------------------------------------------------------

final 속성

	1. final class
		==> 이 클래스는 더 이상 상속이 불가능한 클래스임을 밝히는 속성이다.
			기능을 추가 혹은 변경하지 말고
			현지 기능 그대로만 사용하라는 의미의 클래스이다.
			
			예 ]
				String
		
	2. final 함수
		==> 이 함수는 오버라이드가 불가능한 함수이다.
			따라서 이 속성이 붙어있는 함수는 매우 중요한 함수이므로
			함부로 기능을 바꾸지 말고 현재 기능 그대로 사용하세요...
			라는 의미이다.
	
	3. final 변수
		==> 이 변수는 값을 수정할 수 없는 변수이다.
			즉, 현재 값을 유지해야만 하는 변수이다.
			
			참고 ]
				이 변수는 선언과 동시에 초기화가 이루어져야 한다.

-------------------------------------------------------------------------------------------------------
Object 클래스
==> 자바에서 만들어진 모든 클래스의 최상위 super 클래스의 역할을 하는 클래스
	따라서 자바로 만들어진 모든 클래스는 
	Object 제공하는 모든 기능(멤버 : 변수, 함수)를 자동적으로 사용할 수 있게된다.
	
	참고 ]
		이렇게 최상위 클래스를 만들어 놓은 이유는??
		계층 추적을 원할하게 히도록 하기위한 조치이다.
		즉, 각각의 클래스의 족보를 정확하게 따질 수 있도록 하기 위해서...
		
	참고 ]
		자바에서 만든 모든 클래스는 반드시 상위 클래스를 가지고 있다.
		우리가 이제까지 만든 클래스도 상위 클래스를 가지고 있다.
		만약 강제로 상위 클래스를 지정하지 않으면( extends XXX 하지 않은 경우)
		묵시적으로 Object라는 클래스를 상속 받아서 만들어진다.
		
**
instanceof
==> 특정 클래스를 new 시키면 주소가 만들어지는데
	이 주소가 어떤 클래스 소속의 주소인지를 알아내는 연산자이다.
	연산의 결과는 참, 거짓으로 나오게 된다.
	
	형식 ]
		
		주소 	instanceof	클래스이름
		
	의미 ]
		주소가 가리키고 있는 곳의 내용이
		지정한 클래스 소속인지를 물어보는 것
		
	참고 ]
		소속이라는 개념은 is a 관계를 따져주는 것이다.
		상속 관계를 따지는 개념이 소속이라는 것이다.
		
------------------------------------------------------------------------------------------------------

*****
다형성
==> 하나의 변수를 이용해서 여러 형태의 클래스를 사용하도록 하는 기법

	주소의 형변환(Casting)
	==> 원칙적으로 주소는 다른 형태로 형 변환이 불가능하다.
		즉, 주소는 Heap Type 에 다라 주소가 결정이되므로
		Heap Type 이 다르면 주소를 기억할 수 없다.
		
		예 ]
			int[] a = new float[5]; 	====> X
			Test t = new Calc();		====> X
			
			
	*****
	딱 한가지 경우에 한해서 주소의 형변환이 가능하다.
	상속 관계에 있는 클래스 끼리는 형변환이 가능하다.
	왜? 
		is a 관계가 성립하기 때문에....
		
		자동 형변환
			하위 클래스의 주소(인스턴스)가 상위클래스의 변수에 기억되는 것은 
			자동적으로 형변환을 해준다.
			
		강제 형변환
			상위 클래스의 주소(인스턴스)가 하위 클래스 변수에 기억되는 것은
			원칙적으로 불가능하며
			다만 강제로 형변환을 해주면 가능하다.
			
		예 ]
			class Father {}
			
			class Son extends Father {}
			
			Son s = new Son();
			Father f = s;			==> 자동 형변환
			
			Father f = new Father();
			Son s = f;			===> X
			==>
			Son s = (Son) f;	==> 강제 형변환
			
			
		다형성이란
		주소의 형변환 이론을 기반으로
		상위 클래스의 변수를 이용해서 하위 클래스를 이용할 수 있으며
		다시 말해서 상위 클래스의 변수를 이용하면
		여러 하위클래스를 다룰 수 있다.
		
---------------------------------------------------------------------------------------------
개발자 입장에서 다형성이란
상위 클래스의 변수를 이용하면 하위 클래스(인스턴스)를 사용할 수 있다.(기억시킬 수 있다.)
라는 것이 되므로
상위 클래스이 변수를 이용해서 하위 클래스를 받아서 사용하면 된다.

---------------------------------------------------------------------------------------------
참고 ]
	다형성을 개발자 입장에서 사용하는 방법
		1. 어떤 함수가 상위 클래스를 매개변수로 가지고 있으면
			하위 클래스를 입력해도 상관없다.(<=== 자동 형변환 )
			
			예 ]
				class Grand {}
				class  Father extends Grand {}
				class Son extends Father {}
				
				함수 정의 ]
					void abc(Grand g){
						처리내용...
					}
				
				함수 호출 ]
					
					abc(new Grand());	<=== 당연히 되고
					abc(new Father()); 	<=== 자동형변환
						==> Grand g = new Father();
						
					abc(new Son());		<=== 자동형변환
					
				따라서
				만약 어떤 함수가 Object 를 매개변수로 가지고 있으면
				Object를 입력해주느느 경우는 거의 없다.
				대신에 모든 클래스를 다 입력해도 된다. 라는 의미이다.
				
		2. 어떤 함수가 상위 클래스를 반환값으로 가지고 있으면
			반드시 원하는 하위 클래스 형태로 형변환해서 사용해야 한다.
			
---------------------------------------------------------------------------------------------
추상 클래스
==> 추상 함수를 0개이상 가지고 있는 클래스
	즉, 추상 함수가 한개도 없어도 강제로 추상클래스로 만들 수 있고
	추상함수가 한개라도 있으면 반드시 추상 클래스로 만들어야 한다.
	
-----------------------------------------------------------------------------------------------
	추상함수란?
	==> 함수의 몸체(블럭,{})가 없는 함수를 말한다.
	
		참고 ]
			함수 정의 형식 ]
				
				[접근지정자]	[속성]	반환값타입	함수이름(매개변수리스트) {
					함수 처리내용...
				}
			
		이렇게 함수는 정의를 하는데
		몸체가 없는 것은 기능이 없는 함수를 이야기한다.
		==> 참고로 이 함수는 C 언어에서는 가상 함수에 해당하는 것이다.
		
		형식 ]
			
			[접근지정자]	abstract 	반환값타입	함수이름(매개변수리스트);
			
		예 ]
			public abstract void abc(int a);
			
-----------------------------------------------------------------------------------------------
	추상클래스 만드는 방법
		
		형식 ]
			
			[접근지정자]	abstract	class	클래스이름 {
				변수
				일반함수
				추상함수	도 올 수 있다.
			}
			
	추상 클래스를 만들어 놓은 이유는
		<=== 다형성 구현을 하기 위해서이다.
		
	*****
	추상클래스를 사용하는 방법
	==> 추상클래스는 스스로 new 시킬 수 없다.
		왜냐하면 그 안에는 기능이 없는 함수가 존재할 수 있기 때문에...
		
		1. 다른 클래스에 상속을 시켜준 후
			그 클래스를 new 시키고 
			추상클래스 타입의 변수로 받아서 사용한다.
			==> 실무에서 이렇게 사용하는 경우는 10% 미만....

			참고 ]
				추상클래스를 상속받은 클래스는 
				추상함수를 100% 오버라이딩 해야한다.
		
		***
		2. 실무에서는 추상클래스 안에
				반환값이 자기자신이면서 
				속성이 static 
			인 함수를 사용해서
			객체를 반환받아서 사용하면 된다.
			
참고 ]
	추상클래스가 아님에도
	생성자 함수가 존재하지 않는 클래스가 있다.
	이런 클래스는 생성자 함수가 없는 것이 아니고
	생성자를 private으로 감춰 놓은 것이므로
	역시 new 시켜서 사용할 수 없다.
	이런 클래스 역시
		속성이 static 이면서
		반환값이 자기자신인 함수
	를 사용해서 처리해주면 된다.
			


















