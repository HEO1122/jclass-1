# day12

객체 지향 언어의 특징
	
	1. 상속
	2. 다형성(多形性)
	3. 은닉화/캡슐화
		==> 중요한 데이터를 기억하는 변수는 감춰놓고
			변수를 셋팅하거나 사용할 때는
			함수를 통해서 사용하도록 하는 기법
			
---------------------------------------------------------------------------------------------------

함수의 오버로딩(Overloading : 함수의 중첩)
==> 원칙적으로 같은 클래스 안에서는 함수의 이름은 모두 달라야 한다.
	혹시나 같은 이름의 함수가 같은 클래스내에 존재한다면 에러가 발생한다.
	
	이렇게 함수를 만들다 보면 
		==> 함수의 이름을 만들기가 힘들어진다.
			가독성에 문제가 발생할 수 있다.
			여기서 가독성이란
			함수의 이름만 봐도 그 함수가 어떤 기능을 가진 함수인지를 알아야 하는데...
			함후의 이름을 모두 다르게 만들다 보면
			가독성에 문제가 발생할 수 있다.
			
			따라서 이 문제를 해결하기 위해서 도입된 문법이 
				"함수의 오버로딩"
			이다.
			
			오버로딩이란?
			같은 클래스안에 같은 이름의 함수를 만들 수 있다.
			단, 다음 조건은 반드시 지켜야 한다.
			
			***
			0. 중첩해서 만들려는 함수가 존재해야 한다.
			1. 함수의 이름이 같아야 한다.
			2. 함수의 매개변수리스트의 형태가 달라야 한다.
				여기서 형태는 매겨변수의 갯수, 순서, 형태중 하나 이상이 달라야 한다.
				
				예 ]
					void abc(int a, int b){}
					
					void abc(int b, int a){}		------ X
					int abc(int b, int a){}			------ X
					
					abc(int a) ------------------- O
					abc(float a)	-------------- O
					abc()			-------------- O
					
					참고 ] 매개변수의 이름은 중요하지 않다.
					
			3. 반환값과는 전혀 상관이 없다.
			
	결론 ]
		함수를 호출할 때 정확안 함수를 선택할 수 있도록 해야 한다.
		==> 원래의 함수의 오버로딩 규칙
		
		예 ]
			void abc(){}		------ 1)
			int abc(int a){}	------ 2)
			
			abc();			==> 1) 이 실행
			abc(10);		==> 2) 이 실행
			abc('a');		==> 2) 이 실행 <=== 문자가 정수로 자동 형변환이 되기때문에 가능...
			
			void xyz(int a, float b)	--- 1)
			void xyz(float a, int b)	--- 2)
			
			xyz(2, 3.14f);	==> 1) 이 실행
			xyz(3.14f, 20);	==> 2) 이 실행
			
사용법 ]
==> 다른 사람들이 만든 클래서에도 오버로딩이 구현된 함수들이 존재한다.
	이들 함수를 사용하는 방법은
	원하는 기능을 하는 함수가 요구하는 데이터를 
	형태와 순서에 맞춰서 정확하게 입력해주면 된다.
	
	참고 ]
		형태가 맞지 않더라도 실행되는 경우가 있는데...
		이 경우는 자동 형변환이 되는 경우이다.
		
		예 ]
			
			void abc(double a){}
			
			abc(3.14);		--->  실행된다.
			abc(3.14f);		--->  실행된다. 자동형변환이 되기 때문에...
			abc(100);		--->  실행된다. 자동형변환이 되기 때문에...
	