# day12

객체 지향 언어의 특징
	
	1. 상속
	2. 다형성(多形性)
	3. 은닉화/캡슐화
		==> 중요한 데이터를 기억하는 변수는 감춰놓고
			변수를 셋팅하거나 사용할 때는
			함수를 통해서 사용하도록 하는 기법
			
---------------------------------------------------------------------------------------------------

함수의 오버로딩(Overloading : 함수의 중첩)
==> 원칙적으로 같은 클래스 안에서는 함수의 이름은 모두 달라야 한다.
	혹시나 같은 이름의 함수가 같은 클래스내에 존재한다면 에러가 발생한다.
	
	이렇게 함수를 만들다 보면 
		==> 함수의 이름을 만들기가 힘들어진다.
			가독성에 문제가 발생할 수 있다.
			여기서 가독성이란
			함수의 이름만 봐도 그 함수가 어떤 기능을 가진 함수인지를 알아야 하는데...
			함후의 이름을 모두 다르게 만들다 보면
			가독성에 문제가 발생할 수 있다.
			
			따라서 이 문제를 해결하기 위해서 도입된 문법이 
				"함수의 오버로딩"
			이다.
			
			오버로딩이란?
			같은 클래스안에 같은 이름의 함수를 만들 수 있다.
			단, 다음 조건은 반드시 지켜야 한다.
			
			***
			0. 중첩해서 만들려는 함수가 존재해야 한다.
			1. 함수의 이름이 같아야 한다.
			2. 함수의 매개변수리스트의 형태가 달라야 한다.
				여기서 형태는 매겨변수의 갯수, 순서, 형태중 하나 이상이 달라야 한다.
				
				예 ]
					void abc(int a, int b){}
					
					void abc(int b, int a){}		------ X
					int abc(int b, int a){}			------ X
					
					abc(int a) ------------------- O
					abc(float a)	-------------- O
					abc()			-------------- O
					
					참고 ] 매개변수의 이름은 중요하지 않다.
					
			3. 반환값과는 전혀 상관이 없다.
			
	결론 ]
		함수를 호출할 때 정확안 함수를 선택할 수 있도록 해야 한다.
		==> 원래의 함수의 오버로딩 규칙
		
		예 ]
			void abc(){}		------ 1)
			int abc(int a){}	------ 2)
			
			abc();			==> 1) 이 실행
			abc(10);		==> 2) 이 실행
			abc('a');		==> 2) 이 실행 <=== 문자가 정수로 자동 형변환이 되기때문에 가능...
			
			void xyz(int a, float b)	--- 1)
			void xyz(float a, int b)	--- 2)
			
			xyz(2, 3.14f);	==> 1) 이 실행
			xyz(3.14f, 20);	==> 2) 이 실행
			
사용법 ]
==> 다른 사람들이 만든 클래서에도 오버로딩이 구현된 함수들이 존재한다.
	이들 함수를 사용하는 방법은
	원하는 기능을 하는 함수가 요구하는 데이터를 
	형태와 순서에 맞춰서 정확하게 입력해주면 된다.
	
	참고 ]
		형태가 맞지 않더라도 실행되는 경우가 있는데...
		이 경우는 자동 형변환이 되는 경우이다.
		
		예 ]
			
			void abc(double a){}
			
			abc(3.14);		--->  실행된다.
			abc(3.14f);		--->  실행된다. 자동형변환이 되기 때문에...
			abc(100);		--->  실행된다. 자동형변환이 되기 때문에...
			
			
----------------------------------------------------------------------------------------------------------
# println(), print(), printf() 를 사용해서 객체의 내용을 출력하게 되면
	자동적으로 객체가 가지고 있는 toString() 함수를 호출해서 출력하게 된다.
	
	
==========================================================================================================

가변인자
==> 우리가 함수를 제작할 때
	그 함수가 가지고 있는 매개변수와 동일한 갯수, 형태, 순서를 이용해서 함수를 호출해야만 한다.
	
	void abc(int a){}
	==> 
	abc(5);
	
	void abc(int a, int b){}
	==> abc(5, 2);
	
	만약 함수를 호출하려고 하는데
	호출 할 때마다 같은 타입의 데이터의 갯수가 변경이 되는 경우는 ???
	==> 이런 경우 사용할 수 있는 개념의 매개변수가 가변 인수이다.
	==> 데이터의 갯수에 상관없이
		모든 데이터를 다 받을 수 있도록 하는 것.
		==> 준비된 데이터의 갯수가 달라지더라도 사용할 수 있는 함수를 정의 할 수 있게된다.
		
	형식 ]
		
		[접근지정자]	[속성]	반환값타입	함수이름(데이터타입 ... 변수이름){}
		
		예 ]
			void abc(int ... no){
				==> 이렇게 함수를 정의를 하면
					이 함수는 데이터의 갯수에 관계없이 
					정의된 타입의 데이터를 입력받을 수 있게 된다.
			}

			==> 사용
				
				abc(1);
				abc(2, 3);
				abc(1,2,3,4,5,6,7,8,9);
				
		***
		주의 ]
			가변인수 변수는 자동 배열 변수가 된다.
			따라서 배열 변수처럼 사용해야 된다.
			
		주의 ]
			가변인수 앞에는 다른 매개변수가 와도 상관이 없다.
			가변인수 뒤에는 다른 매개변수가 오면 안된다.
			
			예 ]
				void abc(String str, int ... no){}	--- O
				
				void abc(int ... no, String str){}	--- X

	